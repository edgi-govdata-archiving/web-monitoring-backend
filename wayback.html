

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Python API to Internet Archive Wayback Machine &mdash; web-monitoring-processing 0+untagged.50.g2367454 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Overview of Sources of Archived Web Pages" href="data_sources.html" />
    <link rel="prev" title="web_monitoring.db.Client.add_annotation" href="generated/web_monitoring.db.Client.add_annotation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> web-monitoring-processing
          

          
          </a>

          
            
            
              <div class="version">
                0+untagged.50.g2367454
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="db_api.html">Python API to web-monitoring-db</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python API to Internet Archive Wayback Machine</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tutorial">Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-the-earliest-memento-of-nasa-gov">What is the earliest memento of nasa.gov?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-many-times-does-the-word-mars-appear-on-nasa-gov">How many times does the word ‘mars’ appear on nasa.gov?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#api-documentation">API Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_sources.html">Overview of Sources of Archived Web Pages</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">web-monitoring-processing</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Python API to Internet Archive Wayback Machine</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/wayback.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python-api-to-internet-archive-wayback-machine">
<h1>Python API to Internet Archive Wayback Machine<a class="headerlink" href="#python-api-to-internet-archive-wayback-machine" title="Permalink to this headline">¶</a></h1>
<p>Search for historical mementos (archived copies) of a URL. Download metadata
about the mementos and/or the memento content itself.</p>
<div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-the-earliest-memento-of-nasa-gov">
<h3>What is the earliest memento of nasa.gov?<a class="headerlink" href="#what-is-the-earliest-memento-of-nasa-gov" title="Permalink to this headline">¶</a></h3>
<p>Instantiate a <a class="reference internal" href="#web_monitoring.internetarchive.WaybackClient" title="web_monitoring.internetarchive.WaybackClient"><code class="xref py py-class docutils literal notranslate"><span class="pre">WaybackClient</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">web_monitoring.internetarchive</span> <span class="kn">import</span> <span class="n">WaybackClient</span>

<span class="gp">In [2]: </span><span class="n">client</span> <span class="o">=</span> <span class="n">WaybackClient</span><span class="p">()</span>
</pre></div>
</div>
<p>Search for all Wayback’s records for nasa.gov.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;nasa.gov&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This statement should execute fairly quickly because it doesn’t actually do
much work. The object we get back, <code class="docutils literal notranslate"><span class="pre">results</span></code>, is a <em>generator</em>, a “lazy”
object from which we can pull results, one at a time. As we pull items
out of it, it loads them as needed from the Wayback Machine in chronological
order. We can see that <code class="docutils literal notranslate"><span class="pre">results</span></code> by itself is not informative:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">results</span>
<span class="gh">Out[4]: </span><span class="go">&lt;generator object WaybackClient.search at 0x7f809f1837c8&gt;</span>
</pre></div>
</div>
<p>There are couple ways to pull items out of generator like <code class="docutils literal notranslate"><span class="pre">results</span></code>. One
simple way is to use the built-in Python function <a class="reference external" href="https://docs.python.org/3/library/functions.html#next" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>, like so:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">record</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>
</div>
<p>This takes a moment to run because, now that we’ve asked to see the first item
in the generator, this lazy object goes to fetch a chunk of results from the
Wayback Machine. Looking at the record in detail,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">record</span>
<span class="gh">Out[6]: </span><span class="go">CdxRecord(key=&#39;gov,nasa)/&#39;, timestamp=&#39;19961231235847&#39;, url=&#39;http://www.nasa.gov/&#39;, mime_type=&#39;text/html&#39;, status_code=&#39;200&#39;, digest=&#39;MGIGF4GRGGF5GKV6VNCBAXOE3OR5BTZC&#39;, length=&#39;1811&#39;, date=datetime.datetime(1996, 12, 31, 23, 58, 47), raw_url=&#39;http://web.archive.org/web/19961231235847id_/http://www.nasa.gov/&#39;, view_url=&#39;http://web.archive.org/web/19961231235847/http://www.nasa.gov/&#39;)</span>
</pre></div>
</div>
<p>we can find our answer: Wayback’s first memento of nasa.gov was in 1996. We
can use dot access on <code class="docutils literal notranslate"><span class="pre">record</span></code> to access the date specifically.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">record</span><span class="o">.</span><span class="n">date</span>
<span class="gh">Out[7]: </span><span class="go">datetime.datetime(1996, 12, 31, 23, 58, 47)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-many-times-does-the-word-mars-appear-on-nasa-gov">
<h3>How many times does the word ‘mars’ appear on nasa.gov?<a class="headerlink" href="#how-many-times-does-the-word-mars-appear-on-nasa-gov" title="Permalink to this headline">¶</a></h3>
<p>Above, we access the metadata for the oldest memento on nasa.gov, stored in
the variable <code class="docutils literal notranslate"><span class="pre">record</span></code>. Starting from where we left off, we’ll access the
<em>content</em> of the memento and do a very simple analysis.</p>
<p>The Wayback Machine provides two ways to look at the data it has captured.
There is a copy edited for human viewers on the web, available at the record’s
<code class="docutils literal notranslate"><span class="pre">view_url</span></code>, and there is the original copy of what was captured when the page
was originally scraped, availabe at the record’s <code class="docutils literal notranslate"><span class="pre">raw_url</span></code>. For analysis
purposes, we generally want the <code class="docutils literal notranslate"><span class="pre">raw_url</span></code>.</p>
<p>Let’s download the raw content using <code class="docutils literal notranslate"><span class="pre">WaybackClient</span></code>. (You could download the
content directly with an HTTP library like <code class="docutils literal notranslate"><span class="pre">requests</span></code>, but <code class="docutils literal notranslate"><span class="pre">WaybackClient</span></code>
adds extra tools for dealing with Wayback Machine servers.)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_memento</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">raw_url</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">content</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</pre></div>
</div>
<p>We can use the built-in method <code class="docutils literal notranslate"><span class="pre">count</span></code> on strings to count the number of
times that <code class="docutils literal notranslate"><span class="pre">'mars'</span></code> appears in the content.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">content</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;mars&#39;</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">30</span>
</pre></div>
</div>
<p>This is case-sensitive, so to be more accurate we should convert the content to
lowercase first.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">content</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;mars&#39;</span><span class="p">)</span>
<span class="gh">Out[11]: </span><span class="go">39</span>
</pre></div>
</div>
<p>We picked up a couple additional occurrences that the original count missed.</p>
<p>We have been doing this count on the full HTML source of the page, which
includes both visible text and code that is not visible to a human visitor
browsing the page. We can use a function in <code class="docutils literal notranslate"><span class="pre">web_monitoring</span></code> to extract only
the visible text.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="kn">from</span> <span class="nn">web_monitoring.differs</span> <span class="kn">import</span> <span class="n">_get_visible_text</span>

<span class="gp">In [13]: </span><span class="n">visible</span> <span class="o">=</span> <span class="n">_get_visible_text</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</div>
<p>To get a quick sense of the difference between <code class="docutils literal notranslate"><span class="pre">content</span></code> and <code class="docutils literal notranslate"><span class="pre">visible</span></code>
let’s look at the first 80 characters of each.</p>
<pre class="literal-block">In [14]: print(content[:80])
&lt;HTML&gt;
&lt;HEAD&gt;
  &lt;META NAME=&quot;GENERATOR&quot; CONTENT=&quot;Adobe PageMill 2.0 Mac&quot;&gt;
  &lt;META

In [15]: print(visible[:80])
Welcome to  NASA  and the  Mars Pathfinder Mission !

This is a substitute for t</pre>
<p>And now let’s do the word count on just the visible content.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [16]: </span><span class="n">visible</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;mars&#39;</span><span class="p">)</span>
<span class="gh">Out[16]: </span><span class="go">19</span>
</pre></div>
</div>
<p>Our count of <code class="docutils literal notranslate"><span class="pre">visible</span></code> excludes appearances of <code class="docutils literal notranslate"><span class="pre">'mars'</span></code> that aren’t in the
visible text, such as in link URLs. Both analyses could be interesting,
depending on the context.</p>
</div>
</div>
<div class="section" id="api-documentation">
<h2>API Documentation<a class="headerlink" href="#api-documentation" title="Permalink to this headline">¶</a></h2>
<p>The Wayback Machine exposes its data through two different mechanisms,
implementing two different standards for archival data, the CDX API and the
Memento API. We implement a Python client that can speak both.</p>
<dl class="class">
<dt id="web_monitoring.internetarchive.WaybackClient">
<em class="property">class </em><code class="sig-prename descclassname">web_monitoring.internetarchive.</code><code class="sig-name descname">WaybackClient</code><span class="sig-paren">(</span><em class="sig-param">session=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackClient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackClient" title="Permalink to this definition">¶</a></dt>
<dd><p>A client for retrieving data from the Internet Archive’s Wayback Machine.</p>
<p>You can use a WaybackClient as a context manager. When exiting, it will
close the session it’s using (if you’ve passed in a custom session, make
sure not to use the context manager functionality unless you want to live
dangerously).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>session</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">requests.Session</span></code>, optional</span></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="web_monitoring.internetarchive.WaybackClient.search">
<code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">url</em>, <em class="sig-param">*</em>, <em class="sig-param">matchType=None</em>, <em class="sig-param">limit=None</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">fastLatest=None</em>, <em class="sig-param">gzip=None</em>, <em class="sig-param">from_date=None</em>, <em class="sig-param">to_date=None</em>, <em class="sig-param">filter_field=None</em>, <em class="sig-param">collapse=None</em>, <em class="sig-param">showResumeKey=True</em>, <em class="sig-param">resumeKey=None</em>, <em class="sig-param">page=None</em>, <em class="sig-param">pageSize=None</em>, <em class="sig-param">resolveRevisits=True</em>, <em class="sig-param">skip_malformed_results=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackClient.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackClient.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search archive.org’s CDX API for all captures of a given URL.</p>
<p>This will automatically page through all results for a given search.</p>
<p>Returns an iterator of CdxRecord objects. The StopIteration value is
the total count of found captures.</p>
<p>Note that even URLs without wildcards may return results with different
URLs. Search results are matched by url_key, which is a SURT-formatted,
canonicalized URL:</p>
<ul class="simple">
<li><p>Does not differentiate between HTTP and HTTPS</p></li>
<li><p>Is not case-sensitive</p></li>
<li><p>Treats <code class="docutils literal notranslate"><span class="pre">www.</span></code> and <code class="docutils literal notranslate"><span class="pre">www*.</span></code> subdomains the same as no subdomain at
all</p></li>
</ul>
<p>Note not all CDX API parameters are supported. In particular, this does
not support: <cite>output</cite>, <cite>fl</cite>, <cite>showDupeCount</cite>, <cite>showSkipCount</cite>,
<cite>lastSkipTimestamp</cite>, <cite>showNumPages</cite>, <cite>showPagedIndex</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>url</strong><span class="classifier">str</span></dt><dd><p>The URL to query for captures of.</p>
</dd>
<dt><strong>matchType</strong><span class="classifier">str, optional</span></dt><dd><p>Must be one of ‘exact’, ‘prefix’, ‘host’, or ‘domain’. The default
value is calculated based on the format of <cite>url</cite>.</p>
</dd>
<dt><strong>limit</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of results per page (this iterator will continue to
move through all pages unless <cite>showResumeKey=False</cite>, though).</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>Skip the first N results.</p>
</dd>
<dt><strong>fastLatest</strong><span class="classifier">bool, optional</span></dt><dd><p>Get faster results when using a negative value for <cite>limit</cite>. It may
return a variable number of results.</p>
</dd>
<dt><strong>gzip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether output should be gzipped.</p>
</dd>
<dt><strong>from_date</strong><span class="classifier">datetime, optional</span></dt><dd><p>Only include captures after this date. Equivalent to the
<cite>from</cite> argument in the CDX API.</p>
</dd>
<dt><strong>to_date</strong><span class="classifier">str, optional</span></dt><dd><p>Only include captures before this date. Equivalent to the <cite>to</cite>
argument in the CDX API.</p>
</dd>
<dt><strong>filter_field</strong><span class="classifier">str, optional</span></dt><dd><p>A filter for any field in the results. Equivalent to the <cite>filter</cite>
argument in the CDX API. (format: <cite>[!]field:regex</cite>)</p>
</dd>
<dt><strong>collapse</strong><span class="classifier">str, optional</span></dt><dd><p>Collapse consecutive results that match on a given field. (format:
<cite>fieldname</cite> or <cite>fieldname:N</cite> – N is the number of chars to match.)</p>
</dd>
<dt><strong>showResumeKey</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, don’t continue to iterate through all pages of results.
The default value is True</p>
</dd>
<dt><strong>resumeKey</strong><span class="classifier">str, optional</span></dt><dd><p>Start returning results from a specified resumption point/offset.
The value for this is supplied by the previous page of results when
<cite>showResumeKey</cite> is True.</p>
</dd>
<dt><strong>page</strong><span class="classifier">int, optional</span></dt><dd><p>If using paging start from this page number (note: paging, as
opposed to the using <cite>resumeKey</cite> is somewhat complicated because
of the interplay with indexes and index sizes).</p>
</dd>
<dt><strong>pageSize</strong><span class="classifier">int, optional</span></dt><dd><p>The number of index blocks to examine for each page of results.
Index blocks generally cover about 3,000 items, so setting
<cite>pageSize=1</cite> might return anywhere from 0 to 3,000 results per page.</p>
</dd>
<dt><strong>resolveRevists</strong><span class="classifier">bool, optional</span></dt><dd><p>Attempt to resolve <cite>warc/revisit</cite> records to their actual content
type and response code. Not supported on all CDX servers. Defaults
to True.</p>
</dd>
<dt><strong>skip_malformed_results</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, don’t yield records that look like they have no actual
memento associated with them. Some crawlers will erroneously
attempt to capture bad URLs like <cite>http://mailto:someone&#64;domain.com</cite>
or <cite>http://data:image/jpeg;base64,AF34…</cite> and so on. This is a
filter performed client side and is not a CDX API argument.
(Default: True)</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Any additional CDX API options.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>UnexpectedResponseFormat</dt><dd><p>If the CDX response was not parseable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/internetarchive/wayback/tree/master/wayback-cdx-server">https://github.com/internetarchive/wayback/tree/master/wayback-cdx-server</a></p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="web_monitoring.internetarchive.WaybackClient.list_versions">
<code class="sig-name descname">list_versions</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">url</em>, <em class="sig-param">*</em>, <em class="sig-param">from_date=None</em>, <em class="sig-param">to_date=None</em>, <em class="sig-param">skip_repeats=True</em>, <em class="sig-param">cdx_params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackClient.list_versions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackClient.list_versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Search archive.org for captures of a URL (optionally, within a time span).</p>
<p>This function provides a convenient, use-case-specific interface to
archive.org’s CDX API. For a more direct, low-level API, use
<code class="xref py py-func docutils literal notranslate"><span class="pre">search_cdx()</span></code>.</p>
<p>Note that even URLs without wildcards may return results with multiple
URLs. Search results are matched by url_key, which is a SURT-formatted,
canonicalized URL:</p>
<ul class="simple">
<li><p>Does not differentiate between HTTP and HTTPS</p></li>
<li><p>Is not case-sensitive</p></li>
<li><p>Treats <cite>www.</cite> and <cite>www*.</cite> subdomains the same as no subdomain at all</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>url</strong><span class="classifier">string</span></dt><dd><p>The URL to list versions for. Can contain wildcards.</p>
</dd>
<dt><strong>from_date</strong><span class="classifier">datetime, optional</span></dt><dd><p>Get versions captured after this date.</p>
</dd>
<dt><strong>to_date</strong><span class="classifier">datetime, optional</span></dt><dd><p>Get versions captured before this date.</p>
</dd>
<dt><strong>skip_repeats</strong><span class="classifier">boolean, optional</span></dt><dd><p>Don’t include consecutive captures of the same content (default: True).</p>
</dd>
<dt><strong>cdx_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Additional options to pass directly to the CDX API when querying.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>UnexpectedResponseFormat</dt><dd><p>If the CDX response was not parseable.</p>
</dd>
<dt>ValueError</dt><dd><p>If there were no versions of the given URL.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Grab the datetime and URL of the first nasa.gov snapshot.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">WaybackClient</span><span class="p">()</span> <span class="k">as</span> <span class="n">client</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">versions</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">list_versions</span><span class="p">(</span><span class="s1">&#39;nasa.gov&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">version</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">versions</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">version</span><span class="o">.</span><span class="n">date</span>
<span class="go">datetime.datetime(1996, 12, 31, 23, 58, 47)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">version</span><span class="o">.</span><span class="n">raw_url</span>
<span class="go">&quot;http://web.archive.org/web/19961231235847id\_/http://www.nasa.gov:80/&quot;</span>
</pre></div>
</div>
<p>Loop through all the snapshots.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">client</span><span class="o">.</span><span class="n">list_versions</span><span class="p">(</span><span class="s1">&#39;nasa.gov&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># do something</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="web_monitoring.internetarchive.WaybackClient.get_memento">
<code class="sig-name descname">get_memento</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">url</em>, <em class="sig-param">exact=True</em>, <em class="sig-param">exact_redirects=None</em>, <em class="sig-param">target_window=86400</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackClient.get_memento"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackClient.get_memento" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch a memento from the Wayback Machine. This retrieves the content
that was ultimately returned from a memento, following any redirects
that were present at the time the memento was captured. (That is, if
<cite>http://example.com/a</cite> redirected to <cite>http://example.com/b</cite>, this
returns the memento for <cite>/b</cite> when you request <cite>/a</cite>.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>url</strong><span class="classifier">string</span></dt><dd><p>URL of memento in Wayback (e.g.
<cite>http://web.archive.org/web/20180816111911id_/http://www.nws.noaa.gov/sp/</cite>)</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean, optional</span></dt><dd><p>If false and the requested memento either doesn’t exist or can’t be
played back, this returns the closest-in-time memento to the
requested one, so long as it is within <cite>target_window</cite>.
Default: True</p>
</dd>
<dt><strong>exact_redirects</strong><span class="classifier">boolean, optional</span></dt><dd><p>If false and the requested memento is a redirect whose <em>target</em>
doesn’t exist or or can’t be played back, this returns the closest-
in-time memento to the intended target, so long as it is within
<cite>target_window</cite>. If unset, this will be the same as <cite>exact</cite>.</p>
</dd>
<dt><strong>target_window</strong><span class="classifier">int, optional</span></dt><dd><p>If the memento is of a redirect, allow up to this many seconds
between the capture of the redirect and the capture of the target
URL. (Note this does NOT apply when the originally requested
memento didn’t exist and wayback redirects to the next-closest-in-
-time one. That will always raise a MementoPlaybackError.)
Defaults to 86,400 (24 hours).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier">requests.Response</span></dt><dd><p>An HTTP response with the content of the memento, including a
history of any redirects involved.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="web_monitoring.internetarchive.WaybackClient.timestamped_uri_to_version">
<code class="sig-name descname">timestamped_uri_to_version</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dt</em>, <em class="sig-param">uri</em>, <em class="sig-param">*</em>, <em class="sig-param">url</em>, <em class="sig-param">maintainers=None</em>, <em class="sig-param">tags=None</em>, <em class="sig-param">view_url=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackClient.timestamped_uri_to_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackClient.timestamped_uri_to_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch version content and combine it with metadata to build a Version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">datetime.datetime</span></dt><dd><p>capture time</p>
</dd>
<dt><strong>uri</strong><span class="classifier">string</span></dt><dd><p>URI of version</p>
</dd>
<dt><strong>url</strong><span class="classifier">string</span></dt><dd><p>page URL</p>
</dd>
<dt><strong>maintainers</strong><span class="classifier">list of string, optional</span></dt><dd><p>Entities responsible for maintaining the page, as a list of strings</p>
</dd>
<dt><strong>tags</strong><span class="classifier">list of string, optional</span></dt><dd><p>Any arbitrary “tags” to apply to the page for categorization</p>
</dd>
<dt><strong>view_url</strong><span class="classifier">string, optional</span></dt><dd><p>The archive.org URL for viewing the page (with rewritten links, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier">Version</span></dt><dd><p>suitable for passing to <code class="xref py py-class docutils literal notranslate"><span class="pre">Client.add_versions</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="web_monitoring.internetarchive.WaybackSession">
<em class="property">class </em><code class="sig-prename descclassname">web_monitoring.internetarchive.</code><code class="sig-name descname">WaybackSession</code><span class="sig-paren">(</span><em class="sig-param">retries=6</em>, <em class="sig-param">backoff=2</em>, <em class="sig-param">timeout=None</em>, <em class="sig-param">user_agent=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackSession"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackSession" title="Permalink to this definition">¶</a></dt>
<dd><p>A custom session object that network pools connections and resources for
requests to the Wayback Machine.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>retries</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum number of retries for requests.</p>
</dd>
<dt><strong>backoff</strong><span class="classifier">int or float, optional</span></dt><dd><p>Number of seconds from which to calculate how long to back off and wait
when retrying requests. The first retry is always immediate, but
subsequent retries increase by powers of 2:</p>
<blockquote>
<div><p>seconds = backoff * 2 ^ (retry number - 1)</p>
</div></blockquote>
<p>So if this was <cite>4</cite>, retries would happen after the following delays:
0 seconds, 4 seconds, 8 seconds, 16 seconds, …</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">int or float or tuple of (int or float, int or float), optional</span></dt><dd><p>A timeout to use for all requests. If not set, there will be no
no explicit timeout. See the Requests docs for more:
<a class="reference external" href="http://docs.python-requests.org/en/master/user/advanced/#timeouts">http://docs.python-requests.org/en/master/user/advanced/#timeouts</a></p>
</dd>
<dt><strong>user_agent</strong><span class="classifier">str, optional</span></dt><dd><p>A custom user-agent string to use in all requests.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="web_monitoring.internetarchive.WaybackSession.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/web_monitoring/internetarchive.html#WaybackSession.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#web_monitoring.internetarchive.WaybackSession.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any network connections the session is using.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="data_sources.html" class="btn btn-neutral float-right" title="Overview of Sources of Archived Web Pages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="generated/web_monitoring.db.Client.add_annotation.html" class="btn btn-neutral float-left" title="web_monitoring.db.Client.add_annotation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, EDGI

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>